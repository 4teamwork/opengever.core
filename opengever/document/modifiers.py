from Acquisition import aq_base
from App.class_init import InitializeClass
from Products.CMFEditions.interfaces.IModifier import ICloneModifier
from Products.CMFEditions.interfaces.IModifier import ISaveRetrieveModifier
from Products.CMFEditions.Modifiers import ConditionalTalesModifier
from Products.PageTemplates.PageTemplateFile import PageTemplateFile
from zope.annotation import IAnnotations
from zope.interface import implementer


manage_SkipJournalsAddForm =  \
    PageTemplateFile(
        'www/SkipJournals.pt',
        globals(),
        __name__='manage_SkipJournalsAddForm',
    )


def get_journal_callbacks(values_to_skip):
    """Returns two callbacks for omitting journal annotations during pickling.

    Given a list of references to ftw.journal annotation values
    (PersistentLists), this will return two functions which will be called
    during pickling/unpickling:

    persistent_id:
      This function will be called for every reference that is (recursively)
      found on an object version about to be pickled. It must return `None`
      if the reference should be pickled as usual, or a persistent ID that
      will replace the reference's actual value in the pickle, and could be
      used to restore the object during unpickling (by persistent_load).

    persistent_load:
      This function will be called during unpickling with a persistent ID if
      such an ID is found instead of an actual value. The persistent_load
      function is supposed to turn that ID back to the actual value.

    Because we want to *avoid* pickling ftw.journal annotations, these two
    functions will be implemented in a way that persistent_id just returns
    `True` (to signal that the obj shouldn't be pickled, but replaced by the
    persistent ID), and persistent_load just ignores the persistent ID it
    gets passed, and always returns `None`.

    This will lead to
    - only the value `True` ending up in the pickle
    - the persistent ID being ignored during unpickling (so the value will be
      "restored" to `None`)

    The persistent_id functions returned by onCloneModifiers will be combined
    into one huge persistent_id function that is then passed to Python's
    pickler. It will also namespace the persistent IDs generated by the
    modifiers by prefixing them with the modifier name, and use that namespace
    to look up the appropriate modifier's persistent_load during unpickling.

    (See P.CMFEditions.ModifierRegistryTool.getOnCloneModifiers).

    WARNING: The getCallbacks() function from plone.app.versioningbehavior
    might seem like a good fit here, and will give the impression to work
    as intended, but only on the surface. In practice, it would lead to the
    journals still being pickled in their entirety (during cloning), because
    it uses the repr() of the object as the "persistent ID". For blobs and
    relation lists, for which that function is used in p.a.vb this results in
    relatively short strings. For PersistentLists however their repr() is the
    representation of the entire list.

    So in summary, when called with a list of references to ftw.journal
    PersistentLists, this will prevent journal entries from being pickled
    during cloning when these generated callbacks are returned from
    getOnCloneModifiers.
    """
    obj_ids_to_skip = [id(value) for value in values_to_skip]

    def persistent_id(obj):
        obj_id = id(obj)
        if obj_id in obj_ids_to_skip:
            # It's one of the values that should be skipped.
            # Don't pickle obj, return True to signal that it should be
            # replaced with a "persistent ID"
            return True

        # Any other value - pickle object as usual
        return None

    def persistent_load(persid):
        return None

    return persistent_id, persistent_load


def manage_addSkipJournals(self, id, title=None, REQUEST=None):
    """Add a SkipJournals modifier.
    """
    modifier = SkipJournals(id, title)
    self._setObject(id, modifier)

    if REQUEST is not None:
        REQUEST['RESPONSE'].redirect(self.absolute_url() + '/manage_main')


@implementer(ICloneModifier, ISaveRetrieveModifier)
class SkipJournals:
    """Avoid versioning ftw.journal entries.
    """

    JOURNAL_KEY = 'ftw.journal.journal_entries_annotations_key'

    def __init__(self, id_, title):
        self.id = str(id_)
        self.title = str(title)

    def getOnCloneModifiers(self, obj):
        """Empties ftw.journal annotation entry before pickling the version

        by having the PersistentList replaced with some simple persistent IDs.
        The actual key in the annotations dictionary will be dropped later
        (in the beforeSaveModifier below).

        But avoiding having to pickle the journals on clone helps with
        performance, so we still benefit from already skipping most of them
        here in a clone modifier.
        """
        annotations = IAnnotations(obj)
        journals = [aq_base(annotations.get(self.JOURNAL_KEY, {}))]
        journals = filter(lambda x: x is not None, journals)
        persistent_id, persistent_load = get_journal_callbacks(journals)

        return persistent_id, persistent_load, [], []

    def beforeSaveModifier(self, obj, clone):
        """Removes ftw.journal keys from version's annotations.
        """
        # The journal key in the annotations is supposed to already have been
        # emptied (set to None instead of a PersistentList) by the
        # onCloneModifier above.
        assert IAnnotations(clone).get(self.JOURNAL_KEY) is None

        # Let's now remove the key entirely from annotations
        if self.JOURNAL_KEY in IAnnotations(clone):
            del IAnnotations(clone)[self.JOURNAL_KEY]

        return {}, [], []

    def afterRetrieveModifier(self, obj, repo_clone, preserve=()):
        """Don't restore journal after version retrieval.

        In GEVER, we never use CMFEdition's revert mechanism. Instead, we've
        built our own where we completely ignore anything from historical
        versions except the file's blob.

        Reverting in GEVER:
        - Retrieves the historical version using CMFEditions
        - Plucks the blob from that version
        - Replaces the blob on the current working copy with that one
        - And creates a new version

        We therefore have no need to re-attach the journal to a historical
        version, as long as we never use the CMFEditions revert mechanism
        directly.
        """
        return [], [], {}


InitializeClass(SkipJournals)


modifiers = (
    {
        'id': 'SkipJournals',
        'title': "Skip saving of ftw.journal entries",
        'enabled': True,
        'condition': "python:True",
        'wrapper': ConditionalTalesModifier,
        'modifier': SkipJournals,
        'form': manage_SkipJournalsAddForm,
        'factory': manage_addSkipJournals,
        'icon': 'www/modifier.gif',
    },
)
