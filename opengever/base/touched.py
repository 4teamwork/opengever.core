from BTrees.OOBTree import OOBTree
from datetime import datetime
from DateTime import DateTime
from opengever.base.interfaces import IRecentlyTouchedSettings
from opengever.base.protect import unprotected_write
from opengever.document.behaviors import IBaseDocument
from opengever.document.interfaces import IAutoGeneratedDocument
from operator import itemgetter
from persistent.list import PersistentList
from persistent.mapping import PersistentMapping
from plone import api
from plone.api.portal import get_registry_record
from plone.uuid.interfaces import IUUID
from tzlocal import get_localzone
from zope.annotation import IAnnotations
from zope.component.interfaces import IObjectEvent
from zope.component.interfaces import ObjectEvent
from zope.interface import implements
import logging
import pytz


RECENTLY_TOUCHED_KEY = 'opengever.base.touched.recently_touched'
RECENTLY_TOUCHED_INTERFACES_TO_TRACK = [
    IBaseDocument,
]
RECENTLY_TOUCHED_INTERFACES_TO_SKIP = [
    IAutoGeneratedDocument,
]

logger = logging.getLogger('opengever.base.touched')


class IObjectTouchedEvent(IObjectEvent):
    """An object has been touched"""


class ObjectTouchedEvent(ObjectEvent):
    """An object has been touched"""

    implements(IObjectTouchedEvent)


def handle_object_touched(context, event):
    handler = ObjectTouchedHandler()
    handler.log_touched_object(context, event)


def should_track_touches(obj):
    """Return True if touches for this type should be tracked, False otherwise.
    """
    return (any(iface.providedBy(obj)
                for iface in RECENTLY_TOUCHED_INTERFACES_TO_TRACK)
            and not any(iface.providedBy(obj)
                        for iface in RECENTLY_TOUCHED_INTERFACES_TO_SKIP))


class ObjectTouchedHandler(object):
    """Handles logging of ObjectTouchedEvents.

    This class takes care of logging ObjectTouchedEvents, as well as keeping
    the logs sorted and rotated (truncated to the current limit).
    """

    def __init__(self):
        self.portal = api.portal.get()
        self.catalog = api.portal.get_tool('portal_catalog')

    def ensure_log_initialized(self, user_id):
        ann = unprotected_write(IAnnotations(self.portal))
        if RECENTLY_TOUCHED_KEY not in ann:
            ann[RECENTLY_TOUCHED_KEY] = unprotected_write(OOBTree())

        if user_id not in ann[RECENTLY_TOUCHED_KEY]:
            ann[RECENTLY_TOUCHED_KEY][user_id] = unprotected_write(PersistentList())

    def log_touched_object(self, context, event):
        # Only log touches for tracked types
        if not should_track_touches(context):
            return

        current_user_id = api.user.get_current().id
        self.ensure_log_initialized(current_user_id)
        recently_touched_log = self.get_recently_touched_log(current_user_id)

        # Deduplicate - only keep the most recent entry for any object.
        # (Which is the one we're about to add)
        obj_uid = IUUID(context)
        for entry in recently_touched_log:
            if entry['uid'] == obj_uid:
                recently_touched_log.remove(entry)

        # Store touched items in order - most recent first
        now = datetime.now(pytz.utc).astimezone(get_localzone())
        recently_touched_log.insert(
            0, PersistentMapping({'last_touched': now, 'uid': obj_uid}))

        self.sort(recently_touched_log)
        self.rotate(current_user_id)

    def get_recently_touched_log(self, user_id):
        return unprotected_write(IAnnotations(self.portal)[RECENTLY_TOUCHED_KEY][user_id])

    def sort(self, recently_touched_log):
        """Sort entire list on write - this way, eventual errors self-correct.

        This leads to a minor performance penalty on write, but:
        Sorting an already *mostly* sorted sequence is substantially cheaper
        than having to sort an entirely unordered sequence, especially with
        Python's Timsort. Therefore, the penalty should be minimal.
        """
        recently_touched_log.sort(key=itemgetter('last_touched'), reverse=True)

    def rotate(self, user_id):
        """Rotate recently touched log.

        We basically truncate it to the RECENTLY_TOUCHED_LIMIT.

        However, because the display limit only applies to recently touched
        items (not checked out docs), we need to take care to calculate the
        correct cutoff by "ignoring" checked out docs (adding them to the
        cutoff limit).
        """
        num_checked_out = len(self.catalog(checked_out=user_id))
        limit = get_registry_record('limit', IRecentlyTouchedSettings)
        cutoff = limit + num_checked_out
        truncated = unprotected_write(self.get_recently_touched_log(user_id)[:cutoff])
        unprotected_write(IAnnotations(self.portal)[RECENTLY_TOUCHED_KEY])[user_id] = truncated
