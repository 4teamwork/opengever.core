from Acquisition import aq_inner
from Acquisition import aq_parent
from datetime import date
from datetime import datetime
from dateutil import tz
from opengever.base.behaviors.lifecycle import ILifeCycle
from opengever.base.command import CreateDocumentCommand
from opengever.base.interfaces import IReferenceNumber
from opengever.base.interfaces import ISequenceNumber
from opengever.base.response import IResponseSupported
from opengever.base.role_assignments import ASSIGNMENT_VIA_DOSSIER_RESPONSIBLE
from opengever.base.role_assignments import DossierResponsibleRoleAssignment
from opengever.base.role_assignments import RoleAssignmentManager
from opengever.base.security import elevated_privileges
from opengever.document.behaviors import IBaseDocument
from opengever.document.interfaces import IAutoGeneratedDocument
from opengever.document.interfaces import IDossierJournalPDFMarker
from opengever.dossier import _
from opengever.dossier.behaviors.dossier import ChecklistManager
from opengever.dossier.behaviors.dossier import IDossier
from opengever.dossier.behaviors.dossier import IDossierMarker
from opengever.dossier.behaviors.participation import IParticipationAwareMarker
from opengever.dossier.interfaces import IConstrainTypeDecider
from opengever.dossier.interfaces import IDossierContainerTypes
from opengever.dossier.interfaces import IDossierResolveProperties
from opengever.dossier.utils import check_subdossier_depth_allowed
from opengever.dossier.utils import get_containing_repository_folder
from opengever.meeting import is_meeting_feature_enabled
from opengever.meeting import OPEN_PROPOSAL_STATES
from opengever.ogds.base.actor import Actor
from opengever.propertysheets.utils import get_custom_properties
from opengever.propertysheets.utils import set_custom_property
from opengever.ris import is_ris_feature_enabled
from opengever.task import OPEN_TASK_STATES
from opengever.task.task import ITask
from opengever.workspaceclient import is_workspace_client_feature_enabled
from opengever.workspaceclient.interfaces import ILinkedWorkspaces
from plone import api
from plone.dexterity.content import Container
from plone.dexterity.interfaces import IDexterityFTI
from Products.CMFPlone.interfaces.siteroot import IPloneSiteRoot
from pytz import utc
from zope.component import adapter
from zope.component import getUtility
from zope.component import queryAdapter
from zope.component import queryMultiAdapter
from zope.i18n import translate
from zope.interface import implementer
from zope.interface import implements
from zope.interface import Interface


DOSSIER_STATES_OPEN = [
    'dossier-state-active',
    'opengever_workspace--STATUS--active',
    'opengever_workspace_folder--STATUS--active',
]


DOSSIER_STATES_CLOSED = [
    'dossier-state-inactive',
    'dossier-state-resolved',
]

DOSSIER_STATE_RESOLVED = 'dossier-state-resolved'

DOSSIER_STATES_OFFERABLE = DOSSIER_STATES_CLOSED + ['dossier-state-offered']


def max_date(*dates):
    valid_dates = [as_date(each) for each in dates if each]
    return max(valid_dates) if valid_dates else None


def as_date(datetime_obj):
    if isinstance(datetime_obj, datetime):
        if datetime_obj.tzinfo == utc:
            local_zone = tz.tzlocal()
            return datetime_obj.astimezone(local_zone).date()
        else:
            return datetime_obj.date()

    # It is already a date-object
    return datetime_obj


class DossierContainer(Container):
    """Provide a container for dossiers."""
    implements(IResponseSupported)

    def allowedContentTypes(self, *args, **kwargs):
        types = (
            super(
                DossierContainer,
                self,
            )
            .allowedContentTypes(*args, **kwargs)
        )

        depth = self._get_dossier_depth()

        def filter_type(fti):
            # first we try the more specific one ...
            decider = queryMultiAdapter(
                (self.REQUEST, self, fti),
                IConstrainTypeDecider,
                name=fti.portal_type,
            )

            if not decider:
                # .. then we try the more general one
                decider = queryMultiAdapter(
                    (self.REQUEST, self, fti),
                    IConstrainTypeDecider,
                )

            if decider:
                return decider.addable(depth)

            # if we don't have an adapter, we just allow it
            return True

        return filter(filter_type, types)

    def is_addable(self, portal_type):
        for fti in self.allowedContentTypes():
            if fti.id == portal_type:
                return True

        return False

    def _get_dossier_depth(self):
        # calculate depth
        depth = 0
        obj = self

        while IDossierMarker.providedBy(obj):
            depth += 1
            obj = aq_parent(aq_inner(obj))

            if IPloneSiteRoot.providedBy(obj):
                break

        return depth

    def is_open(self):
        wf_state = api.content.get_state(obj=self)
        return wf_state in DOSSIER_STATES_OPEN

    def is_resolved(self):
        return api.content.get_state(obj=self) == DOSSIER_STATE_RESOLVED

    def get_main_dossier(self):
        """Return the root dossier for the current dossier.

        The root dossier is the dossier that has a repo-folder as its parent
        and thus forms the root of the local dossier hierarchy.

        """
        obj = self
        prev = self

        while IDossierMarker.providedBy(obj):
            prev = obj
            obj = aq_parent(aq_inner(obj))

            if IPloneSiteRoot.providedBy(obj):
                break

        return prev

    def is_subdossier_addable(self):
        """Only checks if the maximum dossier depth allows another level
        of subdossiers but not for permissions.
        """
        return self.is_dossier_structure_addable(additional_depth=1)

    def is_dossier_structure_addable(self, additional_depth=1):
        """Checks if the maximum dossier depth allows additional_depth levels
        of subdossiers but not for permissions.
        """
        depth = self._get_dossier_depth() + additional_depth
        if self.check_dossier_depth_allowed(depth):
            return True

        # Max depth would technically be exceeded.
        # However, if a dossier structure that exceeds the max depth already
        # exists, we'll allow new structures with the same additional
        # depth (or lower).
        main_dossier = self.get_main_dossier()
        subdossiers = main_dossier.get_subdossiers(unrestricted=True)
        main_dossier_path = '/'.join(self.get_main_dossier().getPhysicalPath())

        if subdossiers:
            max_existing_depth = max((
                sub.getPath()[len(main_dossier_path):].count('/') for sub in subdossiers
            ))

            current_depth = '/'.join(self.getPhysicalPath())[len(main_dossier_path):].count('/')
            if (current_depth + additional_depth) <= max_existing_depth:
                return True

        return False

    def check_dossier_depth_allowed(self, depth):
        containing_repository = get_containing_repository_folder(self)
        if not containing_repository:
            return check_subdossier_depth_allowed(depth - 1)
        return containing_repository.is_dossier_structure_addable(depth)

    def has_subdossiers(self):
        return len(self.get_subdossiers()) > 0

    def get_subdossiers(
            self,
            sort_on='created',
            sort_order='ascending',
            review_state=None,
            depth=-1,
            unrestricted=False):

        dossier_path = '/'.join(self.getPhysicalPath())

        query = {
            'path': dict(query=dossier_path, depth=depth),
            'object_provides': IDossierMarker.__identifier__,
        }
        if sort_on:
            query['sort_on'] = sort_on
        if sort_order:
            query['sort_order'] = sort_order

        if review_state:
            query['review_state'] = review_state

        if unrestricted:
            subdossiers = self.portal_catalog.unrestrictedSearchResults(query)
        else:
            subdossiers = self.portal_catalog(query)

        # Remove the object itself from the list of subdossiers
        subdossiers = [
            s
            for s in subdossiers
            if not s.getPath() == dossier_path
        ]

        return subdossiers

    def get_contained_documents(self, unrestricted=False):
        """Returns all documents that are not contained in any subdossier,
        i.e. documents whose parent dossier is this object, this includes
        documents in tasks directly contained in this dossier, etc.
        """
        query = {
            'path': '/'.join(self.getPhysicalPath()),
            'object_provides': IBaseDocument.__identifier__}

        if unrestricted:
            search_function = self.portal_catalog.unrestrictedSearchResults
        else:
            search_function = self.portal_catalog

        documents = search_function(query)

        docs_in_subdossiers = set()
        for subdossier in self.get_subdossiers(depth=1, unrestricted=True):
            results = search_function(
                path=subdossier.getPath(),
                object_provides=IBaseDocument.__identifier__)
            docs_in_subdossiers.update(brain.UID for brain in results)
        return [doc for doc in documents if doc.UID not in docs_in_subdossiers]

    def is_subdossier(self):
        return bool(self.get_parent_dossier())

    def get_parent_dossier(self):
        parent = aq_parent(aq_inner(self))

        if IDossierMarker.providedBy(parent):
            return parent

        return None

    def is_all_supplied(self):
        """Check if all tasks and all documents(incl. mails) are supplied in
        a subdossier provided there are any (active) subdossiers
        """
        subdossiers = self.getFolderContents({
            'object_provides': (
                'opengever.dossier.behaviors.dossier.IDossierMarker'
            ),
        })

        active_dossiers = [
            d
            for d in subdossiers
            if not d.review_state == 'dossier-state-inactive'
        ]

        if active_dossiers:
            results = self.getFolderContents({
                'object_provides': [
                    ITask.__identifier__,
                    IBaseDocument.__identifier__,
                ],
            })

            results = filter(lambda brain: not IAutoGeneratedDocument.providedBy(brain.getObject()), results)
            if results:
                return False

        return True

    def has_active_tasks(self):
        """Check if there are tasks inside the dossier, which
        are not in an end state.
        """
        active_tasks = api.content.find(
            context=self,
            depth=-1,
            object_provides=ITask,
            review_state=OPEN_TASK_STATES,
        )

        # Rejected (sub)tasks should not prevent dossier from being closed.
        active_tasks = [
            t for t in active_tasks if t.review_state != 'task-state-rejected'
        ]

        return bool(active_tasks)

    def has_active_proposals(self):
        """Check if there are proposals inside the dossier, which are open.
        """
        active_proposals = api.content.find(
            context=self,
            depth=-1,
            portal_type="opengever.meeting.proposal",
            review_state=OPEN_PROPOSAL_STATES,
        )

        return bool(active_proposals)

    def is_linked_to_active_workspaces(self):
        """Returns all linked active workspaces accessible by the current
        user.
        """
        if not is_workspace_client_feature_enabled():
            return False

        with elevated_privileges():
            linked_workspaces_adapter = queryAdapter(self, ILinkedWorkspaces)
            if not linked_workspaces_adapter:
                return False

            params = {'review_state': 'opengever_workspace--STATUS--active'}
            active_workspaces = linked_workspaces_adapter.list_non_cached(**params)['items_total']
            return bool(active_workspaces)

    def has_linked_workspaces_without_view_permission(self):
        """It's possible that the currently logged in user has no view permission
        to all linked workspaces. This function returns a boolean to indicate
        if there are such workspaces linked with the current dossier.
        """
        if not is_workspace_client_feature_enabled():
            return False

        with elevated_privileges():
            linked_workspaces_adapter = queryAdapter(self, ILinkedWorkspaces)
            if not linked_workspaces_adapter:
                return False

            linked_workspaces = linked_workspaces_adapter.list_non_cached()['items_total']
        return bool(len(linked_workspaces_adapter.storage.list()) - linked_workspaces)

    def is_all_checked_in(self):
        """Check if all documents in this path are checked in."""
        docs = self.portal_catalog(
            portal_type="opengever.document.document",
            path=dict(
                query='/'.join(self.getPhysicalPath()),
            ),
        )

        for doc in docs:
            if doc.checked_out:
                return False

        return True

    def has_valid_startdate(self):
        """Check if a startdate is valid (if exist)."""
        return bool(IDossier(self).start)

    def has_valid_enddate(self):
        """Check if the enddate is valid.
        """
        dossier = IDossier(self)

        # no enddate is valid because it would be overwritten
        # with the earliest_possible_end_date
        if dossier.end is None:
            return True

        end_date = self.earliest_possible_end_date()
        if end_date:
            # Dossier end date needs to be older
            # than the earliest possible end_date
            if end_date > dossier.end:
                return False

        return True

    def earliest_possible_end_date(self):
        """The earliest possible end-date must be later than all document
        last modification or document dates (except the dossier journal pdf)
        and all dossier start and end dates.
        """

        earliest_possible_end_date = max_date(
            self.earliest_possible_end_date_dossiers(),
            self.earliest_possible_end_date_documents())

        return earliest_possible_end_date

    def earliest_possible_end_date_dossiers(self):
        catalog = api.portal.get_tool('portal_catalog')

        dossier_brains = catalog({
            'path': '/'.join(self.getPhysicalPath()),
            'object_provides': [
                'opengever.dossier.behaviors.dossier.IDossierMarker',
            ],
            'review_state': [
                'dossier-state-active',
                'dossier-state-resolved',
            ],
        })

        earliest_possible_end_date = None
        for dossier_brain in dossier_brains:
            earliest_possible_end_date = max_date(
                earliest_possible_end_date,
                dossier_brain.start,
                dossier_brain.end
            )
        return earliest_possible_end_date

    def earliest_possible_end_date_documents(self):
        catalog = api.portal.get_tool('portal_catalog')

        use_changed = api.portal.get_registry_record(
            'use_changed_for_end_date', IDossierResolveProperties)
        if use_changed:
            date_name = 'changed'
        else:
            date_name = 'document_date'

        document_brains = catalog({
            'path': '/'.join(self.getPhysicalPath()),
            'object_provides': [
                'opengever.document.behaviors.IBaseDocument',
            ],
        })
        autogenerated_document_brains = catalog({
            'path': '/'.join(self.getPhysicalPath()),
            'object_provides': [
                'opengever.document.interfaces.IAutoGeneratedDocument',
            ],
        })

        autogenerated_document_uids = set(
            document.UID for document in autogenerated_document_brains)
        filtered_brains = filter(
            lambda document: document.UID not in autogenerated_document_uids,
            document_brains)

        earliest_possible_end_date = None
        for document_brain in filtered_brains:
            earliest_possible_end_date = max_date(
                earliest_possible_end_date,
                getattr(document_brain, date_name))

        return earliest_possible_end_date

    def get_responsible_actor(self):
        return Actor.user(IDossier(self).responsible)

    @property
    def responsible_label(self):
        return self.get_responsible_actor().get_label()

    def get_sequence_number(self):
        return getUtility(ISequenceNumber).get_number(self)

    def has_participation_support(self):
        return IParticipationAwareMarker.providedBy(self)

    def has_task_support(self):
        return (
            self.portal_types['opengever.task.task']
            in self.allowedContentTypes()
        )

    def get_reference_number(self):
        return IReferenceNumber(self).get_number()

    def get_retention_expiration_date(self):
        """Returns the date when the expiration date expires:

        The start of the next year (the first of january) after the
        retention period.
        """
        if IDossier(self).end:
            year = (
                IDossier(self).end.year
                + int(ILifeCycle(self).retention_period)
            )

            return date(year + 1, 1, 1)

        return None

    def is_retention_period_expired(self):
        if IDossier(self).end:
            return self.get_retention_expiration_date() <= date.today()

        return False

    def offer(self):
        ILifeCycle(self).date_of_submission = date.today()
        api.content.transition(obj=self, transition='dossier-transition-offer')

    def retract(self):
        ILifeCycle(self).date_of_submission = None
        api.content.transition(obj=self, to_state=self.get_former_state())

    def activate(self):
        self.reset_end_date()
        api.content.transition(
            obj=self,
            transition='dossier-transition-activate',
        )

    def reset_end_date(self):
        IDossier(self).end = None
        self.reindexObject(idxs=['end'])

    def get_former_state(self):
        """Returns the end state of the active dossier lifecycle,
        so `dossier-state-resolved` for resolved dossiers or
        `dossier-state-inactive` for deactivated dossiers.
        """
        end_states = ['dossier-state-resolved', 'dossier-state-inactive']

        workflow = api.portal.get_tool('portal_workflow')
        workflow_id = workflow.getWorkflowsFor(self)[0].getId()
        history = workflow.getHistoryOf(workflow_id, self)

        for entry in reversed(history):
            if entry.get('review_state') in end_states:
                return entry.get('review_state')

        return None

    def create_or_update_journal_pdf(self):
        """Create a PDF representation of the dossier journal, and add it to
        the dossier as a normal document.

        If the dossier has an end date, use that date as the document date.
        This prevents the dossier from entering an invalid state with a
        document date outside the dossier's start-end range.
        """
        if not IDossierMarker.providedBy(self) or self.is_subdossier():
            # Only create journal PDF for main dossiers
            return

        view = self.unrestrictedTraverse('pdf-dossier-journal')
        today = api.portal.get_localized_time(
            datetime=datetime.today(), long_format=True)
        filename = u'Journal {}.pdf'.format(today)
        title = _(
            u'title_dossier_journal',
            default=u'Journal of dossier ${title}, ${timestamp}',
            mapping={'title': self.title, 'timestamp': today})
        kwargs = {
            'preserved_as_paper': False,
        }

        dossier = IDossier(self)
        if dossier and dossier.end:
            kwargs['document_date'] = dossier.end

        with elevated_privileges():
            results = api.content.find(
                object_provides=IDossierJournalPDFMarker,
                depth=1,
                context=self)

            if len(results) > 0:
                document = results[0].getObject()
                document.title = translate(title, context=self.REQUEST)
                comment = _(
                    u'Updated with a newer generated version from dossier ${title}.',
                    mapping=dict(title=self.title))
                document.update_file(view.get_data(), create_version=True,
                                     comment=comment)
                return

            document = CreateDocumentCommand(
                self, filename, view.get_data(),
                title=translate(title, context=self.REQUEST),
                content_type='application/pdf',
                interfaces=[IDossierJournalPDFMarker],
                **kwargs).execute()
            document.reindexObject(idxs=['object_provides'])

    @property
    def custom_properties(self):
        return get_custom_properties(self)

    def set_custom_property(self, fieldname, value, reindex=False):
        set_custom_property(self, fieldname, value, reindex)

    def give_permissions_to_responsible(self, remove_existing=False):
        manager = RoleAssignmentManager(self)
        if remove_existing:
            manager.clear_by_causes([ASSIGNMENT_VIA_DOSSIER_RESPONSIBLE])

        assignment = DossierResponsibleRoleAssignment(
            IDossier(self).responsible, ["Role Manager"], self)

        manager.add_or_update_assignments([assignment])

    def progress(self):
        return ChecklistManager(IDossier(self).checklist).progress()

    def has_checklist_items(self):
        return ChecklistManager(IDossier(self).checklist).has_items()


@implementer(IConstrainTypeDecider)
@adapter(Interface, IDossierMarker, IDexterityFTI)
class DefaultConstrainTypeDecider(object):
    """Provide an oracle to decide on container constraints."""

    def __init__(self, request, context, fti):
        self.context = context
        self.request = request
        self.fti = fti

        max_dossier_depth = api.portal.get_registry_record(
            'maximum_dossier_depth',
            interface=IDossierContainerTypes,
        ) + 1

        self.constrain_configuration = {
            'opengever.private.dossier': {
                'opengever.private.dossier': max_dossier_depth
            },
        }

    def addable(self, depth):
        container_type = self.context.portal_type
        factory_type = self.fti.id
        mapping = self.constrain_type_mapping

        for const_ctype, const_depth, const_ftype in mapping:
            if const_ctype == container_type and const_ftype == factory_type:
                return depth < const_depth or const_depth == 0

        if factory_type == u'opengever.ris.proposal':
            return is_ris_feature_enabled()

        if factory_type in [u'opengever.meeting.proposal']:
            return is_meeting_feature_enabled()

        if factory_type == 'opengever.dossier.businesscasedossier':
            return self.context.is_subdossier_addable()

        return True

    @property
    def constrain_type_mapping(self):
        conf = self.constrain_configuration

        for container_type, type_constr in conf.items():
            for factory_type, max_depth in type_constr.items():
                yield container_type, max_depth, factory_type
